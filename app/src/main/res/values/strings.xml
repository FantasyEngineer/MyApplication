<resources>
    <string name="value">value</string>
    <string name="app_name">编程生活app</string>
    <string name="accessibility_des">模拟钉钉打卡</string>
    <string name="accessibility_activity_class">显示其他应用的栈顶activity</string>

    <string name="title_activity_splash">SplashActivity</string>
    <string name="dummy_button">Dummy Button</string>
    <string name="dummy_content">DUMMY\nCONTENT</string>


    <string name="type1">普通类型通知(单行)</string>
    <string name="type2">普通类型通知(多行)</string>
    <string name="type3">消息列表通知(含双图标)</string>
    <string name="type4">含大图类型通知</string>
    <string name="type5">自定义视图通知</string>
    <string name="type6">折叠式双按钮通知</string>
    <string name="type7">进度条通知</string>
    <string name="type8">Android 5.0 新特性</string>
    <string name="type9"></string>


    <string name="title1">淘宝样式</string>
    <string name="title2">网易新闻样式</string>
    <string name="title3">微信消息样式</string>
    <string name="title4">系统截图通知样式</string>
    <string name="title5">应用宝样式</string>
    <string name="title6">Android系统更新样式</string>
    <string name="title7">Android系统下载样式</string>
    <string name="title8">Heads-up 样式</string>
    <string name="title9">清空通知</string>


    <string name="action_settings">Code</string>
    <string name="title_pull_to_zoom_list_view">ZoomListView</string>
    <string name="title_pull_to_zoom_scroll_view">ZoomScrollView</string>
    <string name="title_pull_to_zoom_recycler_view">ZoomRecyclerView</string>
    <string name="action_normal">Normal</string>
    <string name="action_parallax">Parallax</string>
    <string name="action_show_head">Show Head</string>
    <string name="action_hide_head">Hide Head</string>
    <string name="action_disable_zoom">Disable Zoom</string>
    <string name="action_enable_zoom">Enable Zoom</string>


    <string name="client">客户端</string>
    <string name="server">服务端</string>
    <string name="btn_blth_connect">连接设备</string>
    <string name="btn_blth_visiblity">设置蓝牙可见性</string>
    <string name="btn_blth_disconnect">断开连接</string>
    <string name="connect_state">状态</string>
    <string name="progress_scaning">正在扫描</string>
    <string name="progress_connecting">正在连接</string>
    <string name="send">发送</string>
    <string name="write_tip">请输入数字、字母或汉字</string>
    <string name="bluetooth_unopened">蓝牙未开启，请先开启蓝牙</string>


    <string name="txt">layout_scrollFlags根据官方文档，layout_scrollFlags的取值可以为以下几种。scrol设成这个值的效果就好比本View和scrolling view是“一体”的
        具体示例我们在上面已经给出。有一点特别需要我们的注意，为了其他的滚动行为生效，必须同时指定scroll和相应的标记，比如我们想要exitUntilCollapsed所表现的滚动行为，必须将layout_scrollFlags指定为“scroll|exitUntilCollapsed”。exitUntilCollapsed当本View离开屏幕时，会被“折叠”直到达到其最小高度。我们可以这样理解这个效果：当我们开始向上滚动scrolling view时，本View会先接管滚动事件，这样本View会先进行滚动，直到滚动到了最小高度（折叠了），scrolling view才开始实际滚动。而当本View已完全折叠后，再向下滚动scrolling view，直到scrolling view顶部的内容完全显示后，本View才会开始向下滚动以显现出来。Demo如下：（为了演示效果，把ToolBar高度设为了150dp）exitUntilCollapsedenterAlways
        当scrolling view向下滚动时，本View会一起跟着向下滚动。实际上就好比我们同时对scrolling view和本View进行向下滚动，具体效果如下图所示：enterAlways
        仔细观察上图可以发现，与exitUntilCollapsed不同，当scrolling view一开始滚动，ToolBar便已开始跟着滚动，而无需scrolling view将其内容滚动到顶部。layout_scrollFlags根据官方文档，layout_scrollFlags的取值可以为以下几种。scrol设成这个值的效果就好比本View和scrolling view是“一体”的
        具体示例我们在上面已经给出。有一点特别需要我们的注意，为了其他的滚动行为生效，必须同时指定scroll和相应的标记，比如我们想要exitUntilCollapsed所表现的滚动行为，必须将layout_scrollFlags指定为“scroll|exitUntilCollapsed”。exitUntilCollapsed当本View离开屏幕时，会被“折叠”直到达到其最小高度。我们可以这样理解这个效果：当我们开始向上滚动scrolling view时，本View会先接管滚动事件，这样本View会先进行滚动，直到滚动到了最小高度（折叠了），scrolling view才开始实际滚动。而当本View已完全折叠后，再向下滚动scrolling view，直到scrolling view顶部的内容完全显示后，本View才会开始向下滚动以显现出来。Demo如下：（为了演示效果，把ToolBar高度设为了150dp）exitUntilCollapsedenterAlways
        当scrolling view向下滚动时，本View会一起跟着向下滚动。实际上就好比我们同时对scrolling view和本View进行向下滚动，具体效果如下图所示：enterAlways
        仔细观察上图可以发现，与exitUntilCollapsed不同，当scrolling view一开始滚动，ToolBar便已开始跟着滚动，而无需scrolling view将其内容滚动到顶部。
        enterAlwaysCollapsed从名字上就可以看出，这是在enterAlways的基础上，加上了“折叠”的效果。当我们开始向下滚动scrolling view时，本View会一起跟着滚动直到达到其“折叠高度”（即最小高度）。然后当scrolling view滚动至顶部内容完全显示后，再向下滚动scrolling view，本View会继续滚动到完全显示出来。具体效果如下：
        enterAlwaysCollapse注意，要达到上图所示效果，需要把layout_scrollFlags指定为“scroll|enterAlways|enterAlwaysCollapsed”。
        nap在一次滚动结束时，本View很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。到了这里，我们就把AppBarLayout能够实现的滚动行为介绍完毕了，很简单有木有。接下来我们再来介绍一下AppBarLayout的一个亲密朋友——CollapsingToolbarLayout。</string>

    <!--二维码-->
    <string name="app_name_qr">二维码扫描</string>
    <string name="button_ok">确定</string>

    <string name="msg_camera_framework_bug">无法开启摄像头，请在设置-应用管理-宁波银行-权限中开启【相机】权限</string>
    <string name="msg_default_status">将二维码放入框内，即可自动扫描</string>

    <string name="preferences_actions_title">找到条码时</string>
    <string name="preferences_auto_focus_title">使用自动对焦</string>
    <string name="preferences_bulk_mode_summary">连续扫描并保存多个条形码</string>
    <string name="preferences_bulk_mode_title">批量扫描模式</string>
    <string name="preferences_decode_1D_industrial_title">1D工业</string>
    <string name="preferences_decode_1D_product_title">1D产品</string>
    <string name="preferences_decode_Aztec_title">阿兹台克人</string>
    <string name="preferences_decode_Data_Matrix_title">扫描 DM码</string>
    <string name="preferences_decode_PDF417_title">PDF417 (β)</string>
    <string name="preferences_decode_QR_title">扫描 QR码</string>
    <string name="preferences_device_bug_workarounds_title">设备问题解决办法</string>
    <string name="preferences_front_light_auto">自动</string>
    <string name="preferences_front_light_off">待用</string>
    <string name="preferences_front_light_on">活跃</string>
    <string name="preferences_front_light_summary">前灯可用时，打开前灯</string>
    <string name="preferences_front_light_title">前灯</string>
    <string name="preferences_general_title">一般设置</string>
    <string name="preferences_invert_scan_summary">黑色背景上的白色条形码扫描。在某些设备上。</string>
    <string name="preferences_invert_scan_title">反向扫描</string>
    <string name="preferences_name">设置</string>
    <string name="preferences_play_beep_title">提示音</string>
    <string name="preferences_result_title">结果设置</string>
    <string name="preferences_scanning_title">条码类型选择</string>
    <string name="preferences_supplemental_summary">尝试检索关于条码内容的更多信息</string>
    <string name="preferences_supplemental_title">检索更多信息</string>
    <string name="preferences_vibrate_title">振动</string>
    <string name="twocode_tip">二维码扫描信息有误！</string>

    <string name="album">相册</string>
    <string name="flash_lamp_open">开灯</string>
    <string name="flash_lamp_close">关灯</string>
    <string name="barcode_create">生成</string>
    <string name="aidl">与java同级目录下有AIDL接口文件。并且定义了AIDL service实现了接口。同时项目中有aidlclient项目，先安装app运行再安装aidlclient，即可看到效果。
        \nA\nAIDL介绍\n Android Interface definition language,即Android接口定义语言.\nAndroid系统中的进程之间不能共享内存，因此，需要提供一些机制在不同进程之间进行数据通信。
    为了使其他的应用程序也可以访问本应用程序提供的服务，Android系统采用了远程过程调用（Remote Procedure Call，RPC）方式来实现。与很多其他的基于RPC的解决方案一样，Android使用一种接口定义语言
        （Interface Definition Language，IDL）来公开服务的接口。我们知道4个Android应用程序组件中的3个（Activity、BroadcastReceiver和ContentProvider）都可以进行跨
        进程访问，另外一个Android应用程序组件Service同样可以。因此，可以将这种可以跨进程访问的服务称为AIDL（Android Interface Definition Language）服务。</string>

    <string name="rx_framework">  //发送源，也就是被监听方，也就是被观察者 \n
       Observable sender = Observable.create(emitter -> { \n
            emitter.onNext("这是onNext"); \n
            emitter.onNext("这是onNext1"); \n
            emitter.onComplete(); \n
        }); \n
        //观察者，数据接收方\n
        Observer receiver = new Observer()《String》 { \n
            @Override \n
            public void onSubscribe(Disposable d) { \n
 \n
            } \n
 \n
            @Override \n
            public void onNext(String value) { \n
                Toast.makeText(activity, value, Toast.LENGTH_SHORT).show(); \n
            } \n
 \n
            @Override \n
            public void onError(Throwable e) { \n
 \n
            } \n
 \n
            @Override \n
            public void onComplete() { \n
                Toast.makeText(activity, "onComplete", Toast.LENGTH_SHORT).show(); \n
            } \n
        }; \n
        //发送者与接受者绑定 \n
        sender.subscribe(receiver); \n</string>


    <string name="thread_scheduler">
在RxJava 中，Scheduler，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景。\n
● Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n
●Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n
●Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n
●Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n
● Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。\n
有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。subscribeOn(): 指定Observable(被观察者)所在的线程，或者叫做事件产生的线程。 * observeOn(): 指定 Observer(观察者)所运行在的线程，或者叫做事件消费的线程。

    </string>

    <string name="rx_single">
        Single类似于Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值。\n
因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两
个方法：\n
onSuccess - Single发射单个的值到这个方法\n
onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法\n
Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关
系终止。
    </string>
    <string name="rx_subject">
        Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。\n
由于一个Subject订阅一个Observable，它可以触发这个Observable开始发射数据（如果那个Observable是"冷"的--就是说，它等待有订阅才开始发射数据）。因此有这样的效果，Subject
可以把原来那个"冷"的Observable变成"热"的。\n
Subject的种类针对不同的场景一共有四种类型的Subject。他们并不是在所有的实现中全部都存在，而且一些实现使用其它的命名约定（例如，在RxScala中Subject被称作PublishSubject）。
    </string>
    <string name="rx_asynSuject">一个AsyncSubject只在原始Observable完成后，发射来自原始Observable的最后一个值。（如果原始Observable没有发射任何值，AsyncObject也不发射任何值）它会把这最后一个值发射给任何后续的观察者。
\n然而，如果原始的Observable因为发生了错误而终止，AsyncSubject将不会发射任何数据，只是简单的向前传递这个错误通知。
    </string>
    <string name="rx_behaivarSuject">当观察者订阅BehaviorSubject时，它开始发射原始Observable最近发射的数据（如果此时还
没有收到任何数据，它会发射一个默认值），然后继续发射其它任何来自原始Observable的
数据。\n\n
        然而，如果原始的Observable因为发生了一个错误而终止，BehaviorSubject将不会发射任何
数据，只是简单的向前传递这个错误通知。
    </string>
    <string name="rx_serialized">如果你把  Subject  当作一个  Subscriber  使用，注意不要从多个线程中调用它的onNext方法
（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。
要避免此类问题，你可以将Subject转换为一个SerializedSubject  ，类似于这样：
mySafeSubject = new SerializedSubject( myUnsafeSubject );
    </string>


</resources>
